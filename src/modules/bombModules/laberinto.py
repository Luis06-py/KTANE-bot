#from modules.shared import shared_state
import networkx as nx
# Módulo del laberinto
def palabraANumero(palabra): # De modo que 0 -> 1
	try:
		num = float(palabra)
		return str(num-1)
	except: # No es 1, 2, 3...
		listNumeros = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "cero"]
		if palabra.lower() in listNumeros:
			indice = listNumeros.index(palabra.lower())
			return str(indice)
		else:
			return palabra.upper()

data = {
	"Círculos" : {
		((0, 1), (5, 2)): "Lab1",
		((4, 1), (1, 3)): "Lab2",
		((3, 3), (5, 3)): "Lab3",
		((0, 0), (0, 3)): "Lab4",
		((4, 2), (3, 5)): "Lab5",
		((4, 0), (2, 4)): "Lab6",
		((1, 0), (1, 5)): "Lab7",
		((3, 0), (2, 3)): "Lab8",
		((1, 2), (0, 4)): "Lab9"
	},
	"Obstáculos": {
		"Lab1": [((1, 2), (1, 3)), ((4, 4), (4, 5)), ((3, 2), (4, 2)), ((1, 3), (2, 3)), ((3, 1), (4, 1)), ((0, 5), (1, 5)), ((5, 3), (5, 4)), ((0, 2), (0, 3)), ((5, 1), (5, 2)), ((1, 2), (2, 2)), ((3, 0), (3, 1)), ((3, 3), (3, 4)), ((2, 4), (3, 4)), ((2, 1), (3, 1)), ((2, 0), (2, 1)), ((3, 4), (4, 4)), ((0, 1), (1, 1)), ((4, 2), (4, 3)), ((0, 4), (1, 4)), ((1, 4), (2, 4)), ((1, 0), (1, 1)), ((4, 1), (5, 1)), ((4, 4), (5, 4)), ((2, 2), (2, 3)), ((3, 3), (4, 3))],
		"Lab2": [((3, 4), (3, 5)), ((4, 4), (4, 5)), ((2, 2), (3, 2)), ((1, 1), (2, 1)), ((1, 3), (2, 3)), ((3, 1), (4, 1)), ((0, 5), (1, 5)), ((0, 0), (1, 0)), ((0, 2), (0, 3)), ((1, 1), (1, 2)), ((4, 1), (4, 2)), ((3, 3), (3, 4)), ((2, 4), (3, 4)), ((2, 0), (2, 1)), ((5, 2), (5, 3)), ((4, 2), (4, 3)), ((1, 4), (2, 4)), ((0, 2), (1, 2)), ((4, 4), (5, 4)), ((3, 1), (3, 2)), ((1, 3), (1, 4)), ((2, 2), (2, 3)), ((4, 0), (4, 1)), ((5, 0), (5, 1)), ((3, 3), (4, 3))],
		"Lab3": [((1, 2), (1, 3)), ((3, 4), (3, 5)), ((4, 4), (4, 5)), ((1, 0), (2, 0)), ((2, 1), (2, 2)), ((1, 4), (1, 5)), ((1, 3), (2, 3)), ((4, 2), (5, 2)), ((1, 1), (1, 2)), ((0, 2), (0, 3)), ((3, 0), (3, 1)), ((3, 3), (3, 4)), ((0, 1), (1, 1)), ((4, 2), (4, 3)), ((1, 4), (2, 4)), ((1, 0), (1, 1)), ((3, 2), (3, 3)), ((4, 1), (5, 1)), ((3, 1), (3, 2)), ((0, 3), (0, 4)), ((2, 2), (2, 3)), ((4, 0), (4, 1)), ((2, 4), (2, 5)), ((5, 3), (5, 4)), ((4, 3), (4, 4))],
		"Lab4": [((4, 4), (4, 5)), ((2, 2), (3, 2)), ((3, 2), (4, 2)), ((1, 3), (2, 3)), ((4, 2), (5, 2)), ((3, 1), (4, 1)), ((0, 1), (0, 2)), ((1, 1), (1, 2)), ((3, 0), (3, 1)), ((2, 4), (3, 4)), ((0, 3), (1, 3)), ((5, 4), (5, 5)), ((2, 1), (3, 1)), ((2, 0), (2, 1)), ((5, 2), (5, 3)), ((3, 4), (4, 4)), ((4, 3), (5, 3)), ((0, 4), (1, 4)), ((1, 4), (2, 4)), ((1, 0), (1, 1)), ((0, 2), (1, 2)), ((4, 1), (5, 1)), ((2, 2), (2, 3)), ((2, 4), (2, 5)), ((3, 3), (4, 3))],
		"Lab5": [((3, 4), (3, 5)), ((2, 3), (2, 4)), ((1, 5), (2, 5)), ((4, 4), (4, 5)), ((2, 2), (3, 2)), ((1, 1), (2, 1)), ((3, 2), (4, 2)), ((2, 1), (2, 2)), ((1, 4), (1, 5)), ((4, 2), (5, 2)), ((3, 1), (4, 1)), ((0, 0), (1, 0)), ((1, 2), (2, 2)), ((3, 0), (3, 1)), ((3, 3), (3, 4)), ((0, 3), (1, 3)), ((3, 4), (4, 4)), ((4, 3), (5, 3)), ((0, 1), (1, 1)), ((1, 4), (2, 4)), ((2, 3), (3, 3)), ((0, 2), (1, 2)), ((4, 4), (5, 4)), ((4, 0), (4, 1)), ((5, 0), (5, 1))],
		"Lab6": [((1, 2), (1, 3)), ((3, 4), (3, 5)), ((2, 3), (2, 4)), ((2, 2), (3, 2)), ((2, 1), (2, 2)), ((1, 4), (1, 5)), ((4, 2), (5, 2)), ((1, 1), (1, 2)), ((0, 2), (0, 3)), ((4, 1), (4, 2)), ((3, 3), (3, 4)), ((0, 3), (1, 3)), ((2, 1), (3, 1)), ((2, 5), (3, 5)), ((4, 2), (4, 3)), ((1, 4), (2, 4)), ((1, 0), (1, 1)), ((0, 0), (0, 1)), ((4, 1), (5, 1)), ((4, 4), (5, 4)), ((3, 1), (3, 2)), ((2, 2), (2, 3)), ((3, 0), (4, 0)), ((5, 3), (5, 4)), ((4, 3), (4, 4))],
		"Lab7": [((1, 2), (1, 3)), ((3, 4), (3, 5)), ((2, 3), (2, 4)), ((4, 4), (4, 5)), ((2, 1), (2, 2)), ((1, 4), (1, 5)), ((1, 3), (2, 3)), ((4, 2), (5, 2)), ((1, 2), (2, 2)), ((4, 1), (4, 2)), ((2, 1), (3, 1)), ((3, 4), (4, 4)), ((4, 3), (5, 3)), ((2, 5), (3, 5)), ((0, 1), (1, 1)), ((1, 4), (2, 4)), ((2, 3), (3, 3)), ((1, 0), (1, 1)), ((0, 2), (1, 2)), ((4, 1), (5, 1)), ((3, 1), (3, 2)), ((0, 3), (0, 4)), ((2, 0), (3, 0)), ((4, 0), (4, 1)), ((3, 3), (4, 3))],
		"Lab8": [((1, 2), (1, 3)), ((2, 2), (3, 2)), ((1, 1), (2, 1)), ((1, 4), (1, 5)), ((1, 3), (2, 3)), ((4, 2), (5, 2)), ((3, 1), (4, 1)), ((1, 2), (2, 2)), ((4, 1), (4, 2)), ((3, 0), (3, 1)), ((4, 5), (5, 5)), ((2, 0), (2, 1)), ((3, 4), (4, 4)), ((4, 3), (5, 3)), ((1, 4), (2, 4)), ((2, 3), (3, 3)), ((0, 0), (0, 1)), ((0, 2), (1, 2)), ((3, 2), (3, 3)), ((4, 4), (5, 4)), ((0, 3), (0, 4)), ((4, 0), (4, 1)), ((2, 4), (2, 5)), ((3, 3), (4, 3)), ((3, 5), (4, 5))],
		"Lab9": [((4, 4), (4, 5)), ((2, 2), (3, 2)), ((1, 4), (1, 5)), ((1, 3), (2, 3)), ((5, 3), (5, 4)), ((1, 1), (1, 2)), ((5, 1), (5, 2)), ((4, 1), (4, 2)), ((3, 0), (3, 1)), ((3, 3), (3, 4)), ((2, 4), (3, 4)), ((0, 3), (1, 3)), ((4, 5), (5, 5)), ((2, 1), (3, 1)), ((3, 4), (4, 4)), ((4, 2), (4, 3)), ((1, 0), (1, 1)), ((0, 0), (0, 1)), ((0, 2), (1, 2)), ((3, 1), (3, 2)), ((1, 3), (1, 4)), ((2, 2), (2, 3)), ((4, 0), (4, 1)), ((2, 4), (2, 5)), ((3, 3), (4, 3))]
	}
}

def coordenadas_a_direcciones(camino):
    direcciones = []
    for (x1, y1), (x2, y2) in zip(camino, camino[1:]):
        dx, dy = x2 - x1, y2 - y1
        if dx == 1:
            direcciones.append("abajo")
        elif dx == -1:
            direcciones.append("arriba")
        elif dy == 1:
            direcciones.append("derecha")
        elif dy == -1:
            direcciones.append("izquierda")
    return direcciones

def manhattan(a, b):
	return abs(a[0] - b[0]) + abs(a[1] - b[1])

def getRuta(obstáculos, inicio, fin):
	try:
		G = nx.grid_2d_graph(6, 6)
		obstaculos = obstáculos
		for a, b in obstaculos:
			if G.has_edge(a, b):
				G.remove_edge(a, b)
		
		try:
			camino = nx.astar_path(G, inicio, fin, heuristic=manhattan)
			ins = coordenadas_a_direcciones(camino)
			return ins
		except nx.NetworkXNoPath:
			return False
	except:
		return False	

def resolverLaberinto(ind, pos, obj):
	"""Esto resuelve el laberinto, se debe decir número después número"""
	ind = [palabraANumero(x.strip()) for x in ind.lower().split("después") if x.strip()]
	pos = [palabraANumero(x.strip()) for x in pos.lower().split("después") if x.strip()]
	obj = [palabraANumero(x.strip()) for x in obj.lower().split("después") if x.strip()]
	try:
		coordenadas = tuple(map(int, ind))
		origen = tuple(map(int, pos))
		destino = tuple(map(int, obj))
	except:
		return False
	lab = None
	for key, value in data["Círculos"].items():
		if coordenadas in key:
			lab = value
			break
	if lab == None:
		return False
	obstáculos = data["Obstáculos"][lab]
	ruta = getRuta(obstáculos, origen, destino)
	return ruta
	
if __name__ == '__main__':
	print (resolverLaberinto("dos después tres", "cero después cero", "cinco después cinco"))